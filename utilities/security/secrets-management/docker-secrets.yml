# Location: utilities/security/secrets-management/docker-secrets.yml
# Docker Swarm secrets management examples and best practices

version: '3.8'

# Docker Compose file demonstrating various secret management approaches
services:
  # Application using Docker secrets
  web-app:
    image: nginx:alpine
    ports:
      - "80:80"
    secrets:
      - ssl_cert
      - ssl_key
      - db_password
      - api_key
    environment:
      - DB_PASSWORD_FILE=/run/secrets/db_password
      - API_KEY_FILE=/run/secrets/api_key
    configs:
      - source: nginx_config
        target: /etc/nginx/nginx.conf
    deploy:
      replicas: 3
      placement:
        constraints:
          - node.role == worker
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
    networks:
      - frontend
      - backend

  # Database with secret management
  database:
    image: postgres:15-alpine
    secrets:
      - db_password
      - db_ssl_cert
      - db_ssl_key
    environment:
      POSTGRES_DB: appdb
      POSTGRES_USER: appuser
      POSTGRES_PASSWORD_FILE: /run/secrets/db_password
      POSTGRES_INITDB_ARGS: "--auth-host=md5"
    volumes:
      - db_data:/var/lib/postgresql/data
    configs:
      - source: postgres_config
        target: /etc/postgresql/postgresql.conf
    deploy:
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          memory: 1G
          cpus: '0.5'
    networks:
      - backend

  # Redis with password
  cache:
    image: redis:7-alpine
    secrets:
      - redis_password
    command: >
      redis-server
      --requirepass $(cat /run/secrets/redis_password)
      --appendonly yes
      --appendfsync everysec
    volumes:
      - redis_data:/data
    deploy:
      replicas: 1
    networks:
      - backend

  # Secret rotation service
  secret-rotator:
    build:
      context: ./secret-rotator
    secrets:
      - vault_token
      - rotation_config
    environment:
      - VAULT_ADDR=https://vault.company.com
      - VAULT_TOKEN_FILE=/run/secrets/vault_token
      - CONFIG_FILE=/run/secrets/rotation_config
    deploy:
      mode: global
      placement:
        constraints:
          - node.role == manager
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - management

  # Secret backup service
  secret-backup:
    image: alpine:latest
    secrets:
      - backup_key
      - aws_credentials
    environment:
      - AWS_SHARED_CREDENTIALS_FILE=/run/secrets/aws_credentials
      - BACKUP_ENCRYPTION_KEY_FILE=/run/secrets/backup_key
    command: |
      sh -c '
        apk add --no-cache aws-cli gnupg
        # Backup secrets to S3 encrypted
        tar -czf - /run/secrets | 
        gpg --symmetric --batch --yes --passphrase-file /run/secrets/backup_key |
        aws s3 cp - s3://company-secrets-backup/secrets-$(date +%Y%m%d).tar.gz.gpg
      '
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: none
    profiles:
      - backup

# Secrets definitions
secrets:
  # SSL certificates
  ssl_cert:
    file: ./secrets/ssl/cert.pem
    labels:
      - "type=ssl"
      - "environment=production"
      
  ssl_key:
    file: ./secrets/ssl/key.pem
    labels:
      - "type=ssl" 
      - "environment=production"

  # Database credentials
  db_password:
    external: true
    # Created with: echo "secure_password" | docker secret create db_password -
    
  db_ssl_cert:
    file: ./secrets/db/server.crt
    
  db_ssl_key:
    file: ./secrets/db/server.key

  # Application secrets
  api_key:
    external: true
    # Created with: docker secret create api_key ./secrets/api_key.txt

  redis_password:
    external: true

  # Service account tokens
  vault_token:
    external: true

  # Configuration secrets
  rotation_config:
    file: ./secrets/rotation-config.json

  backup_key:
    external: true

  aws_credentials:
    file: ./secrets/aws/credentials

# Configs (non-sensitive configuration)
configs:
  nginx_config:
    file: ./configs/nginx.conf
    
  postgres_config:
    file: ./configs/postgresql.conf

# Networks
networks:
  frontend:
    driver: overlay
    external: false
    
  backend:
    driver: overlay
    internal: true
    
  management:
    driver: overlay
    internal: true

# Volumes
volumes:
  db_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: /opt/postgres-data
      
  redis_data:
    driver: local

---
# Example scripts for secret management

# scripts/create-secrets.sh
#!/bin/bash
# Create Docker secrets

set -e

echo "Creating Docker secrets..."

# SSL certificates
docker secret create ssl_cert ./secrets/ssl/cert.pem
docker secret create ssl_key ./secrets/ssl/key.pem

# Database password
echo "secure_db_password_$(openssl rand -hex 16)" | docker secret create db_password -

# API key
echo "api_$(openssl rand -hex 32)" | docker secret create api_key -

# Redis password
echo "redis_$(openssl rand -hex 16)" | docker secret create redis_password -

# Vault token
echo "hvs.$(openssl rand -hex 32)" | docker secret create vault_token -

# Backup encryption key
openssl rand -hex 32 | docker secret create backup_key -

echo "All secrets created successfully!"

---
# scripts/rotate-secrets.sh  
#!/bin/bash
# Rotate Docker secrets

set -e

SECRET_NAME="$1"
NEW_SECRET_VALUE="$2"

if [ -z "$SECRET_NAME" ] || [ -z "$NEW_SECRET_VALUE" ]; then
    echo "Usage: $0 <secret_name> <new_value>"
    exit 1
fi

echo "Rotating secret: $SECRET_NAME"

# Create new version of secret
NEW_SECRET_NAME="${SECRET_NAME}_$(date +%Y%m%d_%H%M%S)"
echo "$NEW_SECRET_VALUE" | docker secret create "$NEW_SECRET_NAME" -

# Update service to use new secret
SERVICES=$(docker service ls --filter "label=uses-secret=$SECRET_NAME" --format "{{.Name}}")

for service in $SERVICES; do
    echo "Updating service: $service"
    
    # Remove old secret and add new one
    docker service update \
        --secret-rm "$SECRET_NAME" \
        --secret-add "source=$NEW_SECRET_NAME,target=$SECRET_NAME" \
        "$service"
done

# Wait for rollout to complete
for service in $SERVICES; do
    echo "Waiting for $service to update..."
    docker service logs -f "$service" &
    
    # Wait for service to be stable
    while [ "$(docker service ps "$service" --filter "desired-state=running" --format "{{.CurrentState}}" | grep -c "Running")" -lt 1 ]; do
        sleep 5
    done
done

# Remove old secret after successful rollout
echo "Removing old secret: $SECRET_NAME"
docker secret rm "$SECRET_NAME" || echo "Warning: Could not remove old secret"

# Rename new secret to original name (Docker doesn't support this directly)
echo "Secret rotation completed!"
echo "Note: New secret is named $NEW_SECRET_NAME"

---
# secret-rotator/Dockerfile
FROM alpine:3.19

RUN apk add --no-cache \
    bash \
    curl \
    jq \
    docker-cli \
    openssl

COPY rotate-secrets.py /usr/local/bin/
COPY rotation-schedule.json /etc/rotation/

RUN chmod +x /usr/local/bin/rotate-secrets.py

CMD ["/usr/local/bin/rotate-secrets.py"]

---
# secret-rotator/rotate-secrets.py
#!/usr/bin/env python3
# Automated secret rotation service

import docker
import json
import time
import logging
import hashlib
import os
from datetime import datetime, timedelta

class SecretRotator:
    def __init__(self):
        self.client = docker.from_env()
        self.config = self.load_config()
        self.setup_logging()
        
    def load_config(self):
        """Load rotation configuration"""
        config_file = os.getenv('CONFIG_FILE', '/run/secrets/rotation_config')
        with open(config_file) as f:
            return json.load(f)
    
    def setup_logging(self):
        """Setup logging"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)
    
    def generate_password(self, length=32):
        """Generate secure password"""
        import secrets
        import string
        
        alphabet = string.ascii_letters + string.digits + "!@#$%^&*"
        return ''.join(secrets.choice(alphabet) for _ in range(length))
    
    def rotate_secret(self, secret_name, secret_config):
        """Rotate a specific secret"""
        try:
            self.logger.info(f"Rotating secret: {secret_name}")
            
            # Generate new secret value
            if secret_config['type'] == 'password':
                new_value = self.generate_password(secret_config.get('length', 32))
            elif secret_config['type'] == 'api_key':
                new_value = f"ak_{self.generate_password(48)}"
            else:
                self.logger.warning(f"Unknown secret type: {secret_config['type']}")
                return False
            
            # Create new secret
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            new_secret_name = f"{secret_name}_{timestamp}"
            
            self.client.secrets.create(
                name=new_secret_name,
                data=new_value.encode('utf-8'),
                labels={'rotated_from': secret_name, 'created': timestamp}
            )
            
            # Update services
            services_updated = []
            for service_name in secret_config.get('services', []):
                try:
                    service = self.client.services.get(service_name)
                    
                    # Update service secret
                    service.update(
                        secrets=[
                            docker.types.SecretReference(
                                secret_id=new_secret_name,
                                secret_name=secret_name
                            )
                        ]
                    )
                    services_updated.append(service_name)
                    self.logger.info(f"Updated service: {service_name}")
                    
                except Exception as e:
                    self.logger.error(f"Failed to update service {service_name}: {e}")
            
            # Wait for services to update
            time.sleep(60)
            
            # Remove old secret
            try:
                old_secret = self.client.secrets.get(secret_name)
                old_secret.remove()
                self.logger.info(f"Removed old secret: {secret_name}")
            except Exception as e:
                self.logger.warning(f"Could not remove old secret: {e}")
            
            self.logger.info(f"Successfully rotated secret: {secret_name}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to rotate secret {secret_name}: {e}")
            return False
    
    def should_rotate(self, secret_name, secret_config):
        """Check if secret should be rotated"""
        try:
            secret = self.client.secrets.get(secret_name)
            created_at = secret.attrs['CreatedAt']
            created_time = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
            
            rotation_days = secret_config.get('rotation_days', 30)
            rotation_threshold = datetime.now() - timedelta(days=rotation_days)
            
            return created_time < rotation_threshold
            
        except Exception as e:
            self.logger.error(f"Could not check rotation status for {secret_name}: {e}")
            return False
    
    def run_rotation_cycle(self):
        """Run one rotation cycle"""
        self.logger.info("Starting secret rotation cycle")
        
        for secret_name, secret_config in self.config.get('secrets', {}).items():
            if secret_config.get('auto_rotate', False):
                if self.should_rotate(secret_name, secret_config):
                    self.rotate_secret(secret_name, secret_config)
                else:
                    self.logger.info(f"Secret {secret_name} does not need rotation")
    
    def run(self):
        """Run the rotation service"""
        self.logger.info("Starting secret rotation service")
        
        while True:
            try:
                self.run_rotation_cycle()
                
                # Sleep for configured interval
                interval = self.config.get('check_interval_hours', 24) * 3600
                self.logger.info(f"Sleeping for {interval} seconds")
                time.sleep(interval)
                
            except KeyboardInterrupt:
                self.logger.info("Received interrupt signal, shutting down")
                break
            except Exception as e:
                self.logger.error(f"Error in rotation cycle: {e}")
                time.sleep(300)  # Wait 5 minutes before retry

if __name__ == "__main__":
    rotator = SecretRotator()
    rotator.run()

---
# Example rotation configuration
# secrets/rotation-config.json
{
  "check_interval_hours": 24,
  "secrets": {
    "db_password": {
      "type": "password",
      "length": 32,
      "auto_rotate": true,
      "rotation_days": 30,
      "services": ["database", "web-app"]
    },
    "api_key": {
      "type": "api_key", 
      "auto_rotate": true,
      "rotation_days": 90,
      "services": ["web-app"]
    },
    "redis_password": {
      "type": "password",
      "length": 24,
      "auto_rotate": true,
      "rotation_days": 60,
      "services": ["cache", "web-app"]
    }
  }
}

---
# Usage Examples:

# 1. Deploy the stack:
#    docker stack deploy -c docker-secrets.yml myapp

# 2. Create secrets manually:
#    echo "mysecret" | docker secret create db_password -

# 3. List secrets:
#    docker secret ls

# 4. Inspect secret (metadata only):
#    docker secret inspect db_password

# 5. Update service with new secret:
#    docker service update --secret-rm old_secret --secret-add new_secret myapp_web

# 6. Rotate secret:
#    ./scripts/rotate-secrets.sh db_password "new_password_value"

# 7. Backup secrets (metadata):
#    docker secret ls --format "{{.Name}}" | xargs -I {} docker secret inspect {} > secrets-backup.json

# 8. Remove secret:
#    docker secret rm secret_name

# 9. Run secret rotation service:
#    docker-compose --profile backup up secret-rotator

# Security Best Practices:
# - Never log secret values
# - Use external secret stores when possible  
# - Implement proper RBAC
# - Regular secret rotation
# - Monitor secret access
# - Encrypt secrets at rest
# - Use least privilege principle
# - Audit secret operations