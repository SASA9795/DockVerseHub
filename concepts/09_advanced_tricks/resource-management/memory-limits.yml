# 09_advanced_tricks/resource-management/memory-limits.yml

version: '3.8'

services:
  # Example 1: Basic memory limits
  web-app:
    image: nginx:alpine
    container_name: web-basic
    deploy:
      resources:
        limits:
          memory: 128M
        reservations:
          memory: 64M
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost/"]
      interval: 30s
      timeout: 10s

  # Example 2: Memory limits with swap control
  api-service:
    image: python:3.11-alpine
    container_name: api-memory
    deploy:
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M
    mem_swappiness: 0  # Disable swap usage
    oom_kill_disable: false
    command: |
      sh -c '
      pip install flask psutil &&
      cat > app.py << "EOF"
import flask
import psutil
import gc
from flask import jsonify

app = flask.Flask(__name__)

@app.route("/health")
def health():
    return jsonify({"status": "healthy"})

@app.route("/memory")
def memory_info():
    process = psutil.Process()
    memory_info = process.memory_info()
    
    return jsonify({
        "rss": memory_info.rss,
        "vms": memory_info.vms,
        "percent": process.memory_percent(),
        "available": psutil.virtual_memory().available
    })

@app.route("/gc")
def garbage_collect():
    gc.collect()
    return jsonify({"message": "Garbage collection completed"})

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8080)
EOF
      python app.py
      '

  # Example 3: Memory-intensive application with monitoring
  data-processor:
    image: python:3.11-alpine
    container_name: data-processor
    deploy:
      resources:
        limits:
          memory: 2G
        reservations:
          memory: 1G
    environment:
      - PYTHONUNBUFFERED=1
      - MALLOC_TRIM_THRESHOLD_=100000
    command: |
      sh -c '
      pip install psutil numpy &&
      cat > processor.py << "EOF"
import time
import numpy as np
import psutil
import gc
import os

def monitor_memory():
    process = psutil.Process()
    memory_mb = process.memory_info().rss / 1024 / 1024
    print(f"Memory usage: {memory_mb:.2f} MB")
    return memory_mb

def process_data_batch(size):
    print(f"Processing batch of size {size}")
    
    # Simulate memory-intensive processing
    data = np.random.rand(size, 1000)
    result = np.mean(data, axis=1)
    
    # Force memory cleanup
    del data
    gc.collect()
    
    return len(result)

def main():
    print("Starting memory-controlled data processor...")
    batch_sizes = [1000, 5000, 10000, 20000]
    
    for batch_size in batch_sizes:
        print(f"\\n--- Processing batch size {batch_size} ---")
        
        memory_before = monitor_memory()
        
        try:
            processed = process_data_batch(batch_size)
            print(f"Processed {processed} items")
            
            memory_after = monitor_memory()
            print(f"Memory delta: {memory_after - memory_before:.2f} MB")
            
            # Check memory limits
            if memory_after > 1800:  # 1.8GB warning threshold
                print("WARNING: Approaching memory limit!")
                gc.collect()
                
        except MemoryError:
            print("ERROR: Out of memory!")
            gc.collect()
        
        time.sleep(5)
    
    print("Data processing completed")

if __name__ == "__main__":
    main()
EOF
      python processor.py
      '

  # Example 4: Database with memory tuning
  database:
    image: postgres:15-alpine
    container_name: postgres-memory
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 512M
    environment:
      - POSTGRES_DB=testdb
      - POSTGRES_USER=testuser
      - POSTGRES_PASSWORD=testpass
      - POSTGRES_SHARED_BUFFERS=256MB
      - POSTGRES_EFFECTIVE_CACHE_SIZE=768MB
      - POSTGRES_WORK_MEM=16MB
      - POSTGRES_MAINTENANCE_WORK_MEM=128MB
    command: |
      postgres
      -c shared_buffers=256MB
      -c effective_cache_size=768MB
      -c work_mem=16MB
      -c maintenance_work_mem=128MB
      -c max_connections=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=200

  # Example 5: Redis with memory optimization
  cache:
    image: redis:7-alpine
    container_name: redis-memory
    deploy:
      resources:
        limits:
          memory: 256M
        reservations:
          memory: 128M
    command: |
      redis-server
      --maxmemory 200mb
      --maxmemory-policy allkeys-lru
      --save 900 1
      --save 300 10
      --save 60 10000

  # Example 6: JVM application with heap limits
  java-app:
    image: openjdk:11-jre-slim
    container_name: java-memory
    deploy:
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M
    environment:
      - JAVA_OPTS=-Xmx384m -Xms256m -XX:+UseG1GC -XX:MaxGCPauseMillis=200
    command: |
      sh -c '
      cat > MemoryTest.java << "EOF"
import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;
import java.util.ArrayList;
import java.util.List;

public class MemoryTest {
    public static void main(String[] args) throws InterruptedException {
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        List<byte[]> memory = new ArrayList<>();
        
        System.out.println("Starting JVM memory test...");
        
        for (int i = 0; i < 100; i++) {
            // Allocate 1MB
            memory.add(new byte[1024 * 1024]);
            
            long heapUsed = memoryBean.getHeapMemoryUsage().getUsed();
            long heapMax = memoryBean.getHeapMemoryUsage().getMax();
            
            System.out.printf("Iteration %d: Heap used: %d MB / %d MB\\n", 
                i, heapUsed / 1024 / 1024, heapMax / 1024 / 1024);
            
            if (i % 10 == 0 && i > 0) {
                System.gc();
                Thread.sleep(1000);
            }
        }
        
        System.out.println("Memory test completed");
    }
}
EOF
      javac MemoryTest.java
      java $JAVA_OPTS MemoryTest
      '

  # Example 7: Memory monitoring service
  memory-monitor:
    image: alpine:latest
    container_name: memory-monitor
    volumes:
      - /sys/fs/cgroup:/sys/fs/cgroup:ro
    command: |
      sh -c '
      apk add --no-cache curl jq
      
      monitor_container_memory() {
        local container=$1
        local cgroup_path="/sys/fs/cgroup/memory/docker/$container"
        
        if [ -d "$cgroup_path" ]; then
          local usage=$(cat $cgroup_path/memory.usage_in_bytes 2>/dev/null || echo 0)
          local limit=$(cat $cgroup_path/memory.limit_in_bytes 2>/dev/null || echo 0)
          local usage_mb=$((usage / 1024 / 1024))
          local limit_mb=$((limit / 1024 / 1024))
          local percent=$((usage * 100 / limit))
          
          echo "$container: ${usage_mb}MB / ${limit_mb}MB (${percent}%)"
          
          if [ $percent -gt 90 ]; then
            echo "WARNING: $container using >90% memory!"
          fi
        fi
      }
      
      while true; do
        echo "=== Memory Usage Report $(date) ==="
        
        # Monitor specific containers
        for container in web-basic api-memory data-processor postgres-memory redis-memory java-memory; do
          container_id=$(docker ps -q -f name=$container 2>/dev/null)
          if [ -n "$container_id" ]; then
            monitor_container_memory $container_id
          fi
        done
        
        echo "================================="
        sleep 30
      done
      '

  # Example 8: Memory stress testing
  stress-test:
    image: alpine:latest
    container_name: memory-stress
    deploy:
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M
    profiles:
      - stress
    command: |
      sh -c '
      apk add --no-cache stress-ng
      
      echo "Starting memory stress test..."
      echo "Container memory limit: 512MB"
      
      # Test 1: Gradual memory increase
      echo "Test 1: Gradual memory allocation"
      stress-ng --vm 1 --vm-bytes 100M --vm-method all --timeout 30s
      
      # Test 2: Memory thrashing
      echo "Test 2: Memory thrashing test"
      stress-ng --vm 2 --vm-bytes 200M --vm-method all --timeout 30s
      
      # Test 3: Approach limit
      echo "Test 3: Approaching memory limit"
      stress-ng --vm 1 --vm-bytes 400M --vm-method all --timeout 30s
      
      echo "Memory stress test completed"
      '

networks:
  default:
    driver: bridge

# Usage examples:
#
# Start all services:
# docker-compose -f memory-limits.yml up -d
#
# Run stress test:
# docker-compose -f memory-limits.yml --profile stress up stress-test
#
# Monitor memory usage:
# docker stats --format "table {{.Container}}\t{{.MemUsage}}\t{{.MemPerc}}"
#
# Check memory limits:
# docker inspect <container> --format='{{.HostConfig.Memory}}'