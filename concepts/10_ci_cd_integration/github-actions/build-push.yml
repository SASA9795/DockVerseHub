# 10_ci_cd_integration/github-actions/build-push.yml

name: Build and Push Docker Images

on:
  push:
    branches: [main, develop]
    tags: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Build and test job
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    strategy:
      matrix:
        platform: [linux/amd64, linux/arm64]

    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-metadata: ${{ steps.meta.outputs.json }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true
          driver-opts: |
            image=moby/buildkit:buildx-stable-1

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
          labels: |
            org.opencontainers.image.title=${{ github.repository }}
            org.opencontainers.image.description=Application container
            org.opencontainers.image.vendor=${{ github.repository_owner }}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: ${{ matrix.platform }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDTIME=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VERSION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.version'] }}
            REVISION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.revision'] }}
          secrets: |
            GIT_AUTH_TOKEN=${{ secrets.GIT_AUTH_TOKEN }}

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Upload SBOM as artifact
        uses: actions/upload-artifact@v3
        with:
          name: sbom-${{ matrix.platform }}
          path: sbom.spdx.json

  # Security scanning job
  security-scan:
    runs-on: ubuntu-latest
    needs: build
    permissions:
      security-events: write

    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-digest }}
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL,HIGH"

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: "trivy-results.sarif"

      - name: Run Snyk container scan
        uses: snyk/actions/docker@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-digest }}
          args: --severity-threshold=high --json-file-output=snyk-results.json

      - name: Upload Snyk results
        uses: actions/upload-artifact@v3
        with:
          name: snyk-scan-results
          path: snyk-results.json

  # Integration tests
  integration-test:
    runs-on: ubuntu-latest
    needs: build

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Start application container
        run: |
          docker run -d \
            --name app-test \
            --network ${{ job.services.postgres.network }} \
            --network ${{ job.services.redis.network }} \
            -e DATABASE_URL=postgres://postgres:testpass@postgres:5432/testdb \
            -e REDIS_URL=redis://redis:6379 \
            -p 3000:3000 \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-digest }}

      - name: Wait for application
        run: |
          timeout 60 bash -c 'until curl -f http://localhost:3000/health; do sleep 2; done'

      - name: Run integration tests
        run: |
          docker run --rm \
            --network container:app-test \
            -v ${{ github.workspace }}/tests:/tests \
            node:18-alpine \
            sh -c "cd /tests && npm ci && npm run test:integration"

      - name: Cleanup
        if: always()
        run: docker rm -f app-test

  # Performance testing
  performance-test:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Start application
        run: |
          docker run -d \
            --name perf-test \
            -p 3000:3000 \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-digest }}

      - name: Install K6
        run: |
          curl https://github.com/grafana/k6/releases/download/v0.46.0/k6-v0.46.0-linux-amd64.tar.gz -L | tar xvz --strip-components 1

      - name: Run performance tests
        run: |
          ./k6 run --out json=results.json tests/performance/load-test.js

      - name: Upload performance results
        uses: actions/upload-artifact@v3
        with:
          name: performance-results
          path: results.json

      - name: Cleanup
        if: always()
        run: docker rm -f perf-test

  # Deployment preparation
  deploy-prep:
    runs-on: ubuntu-latest
    needs: [build, security-scan, integration-test]
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')

    outputs:
      deployment-manifest: ${{ steps.manifest.outputs.manifest }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate deployment manifest
        id: manifest
        run: |
          cat > deployment.yaml << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: app-deployment
            labels:
              app: myapp
              version: ${{ needs.build.outputs.image-metadata.labels['org.opencontainers.image.version'] }}
          spec:
            replicas: 3
            selector:
              matchLabels:
                app: myapp
            template:
              metadata:
                labels:
                  app: myapp
              spec:
                containers:
                - name: app
                  image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build.outputs.image-digest }}
                  ports:
                  - containerPort: 3000
                  env:
                  - name: NODE_ENV
                    value: production
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "250m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 3000
                    initialDelaySeconds: 30
                    periodSeconds: 10
                  readinessProbe:
                    httpGet:
                      path: /ready
                      port: 3000
                    initialDelaySeconds: 5
                    periodSeconds: 5
          EOF

          echo "manifest<<EOF" >> $GITHUB_OUTPUT
          cat deployment.yaml >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload deployment manifest
        uses: actions/upload-artifact@v3
        with:
          name: deployment-manifest
          path: deployment.yaml

  # Notification job
  notify:
    runs-on: ubuntu-latest
    needs: [build, security-scan, integration-test, deploy-prep]
    if: always()

    steps:
      - name: Send Slack notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            Build Status: ${{ needs.build.result }}
            Security Scan: ${{ needs.security-scan.result }}
            Integration Tests: ${{ needs.integration-test.result }}

            Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
            Digest: ${{ needs.build.outputs.image-digest }}

            Commit: ${{ github.sha }}
            Author: ${{ github.actor }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: always()

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/v') && needs.build.result == 'success'
        with:
          files: |
            deployment.yaml
          body: |
            ## Docker Image

            ```
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}
            ```

            **Image Digest:** `${{ needs.build.outputs.image-digest }}`

            ## Security Scan Results
            - Trivy: ${{ needs.security-scan.result }}
            - Container vulnerabilities checked

            ## Testing
            - Integration tests: ${{ needs.integration-test.result }}
            - Performance tests: ${{ needs.performance-test.result || 'skipped' }}

            ## Deployment
            Use the attached `deployment.yaml` for Kubernetes deployment.
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
