# 10_ci_cd_integration/github-actions/release-automation.yml

name: Release Automation Pipeline

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      release_type:
        description: "Release type"
        required: true
        default: "patch"
        type: choice
        options:
          - major
          - minor
          - patch
          - prerelease
      prerelease:
        description: "Mark as prerelease"
        required: false
        default: false
        type: boolean
      draft:
        description: "Create draft release"
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  NODE_VERSION: "18"

jobs:
  # Version management and validation
  version-management:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      changelog: ${{ steps.changelog.outputs.changelog }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Configure Git
        run: |
          git config user.name "Release Bot"
          git config user.email "release-bot@example.com"

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Automated version bump
            case "${{ github.event.inputs.release_type }}" in
              major)
                NEW_VERSION=$(npm version major --no-git-tag-version)
                ;;
              minor)
                NEW_VERSION=$(npm version minor --no-git-tag-version)
                ;;
              patch)
                NEW_VERSION=$(npm version patch --no-git-tag-version)
                ;;
              prerelease)
                NEW_VERSION=$(npm version prerelease --preid=rc --no-git-tag-version)
                ;;
            esac
            echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT
            echo "tag=${NEW_VERSION}" >> $GITHUB_OUTPUT
          else
            # Extract from tag
            VERSION=${GITHUB_REF#refs/tags/}
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
            echo "tag=${VERSION}" >> $GITHUB_OUTPUT
          fi

      - name: Generate changelog
        id: changelog
        run: |
          # Install conventional-changelog-cli
          npm install -g conventional-changelog-cli

          # Generate changelog
          conventional-changelog -p angular -i CHANGELOG.md -s -r 0

          # Extract latest entry for release notes
          CHANGELOG_CONTENT=$(sed -n '/^# /,/^# /p' CHANGELOG.md | sed '$d' | tail -n +2)

          # Save changelog to output (escape newlines)
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Validate version
        run: |
          # Ensure version follows semantic versioning
          if ! [[ "${{ steps.version.outputs.version }}" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
            echo "Invalid version format: ${{ steps.version.outputs.version }}"
            exit 1
          fi

          # Check if tag already exists (for manual releases)
          if git tag -l | grep -q "^${{ steps.version.outputs.tag }}$"; then
            echo "Tag ${{ steps.version.outputs.tag }} already exists"
            exit 1
          fi

      - name: Update package files
        if: github.event_name == 'workflow_dispatch'
        run: |
          # Update package.json version
          npm version ${{ steps.version.outputs.version }} --no-git-tag-version

          # Commit version changes
          git add package*.json CHANGELOG.md
          git commit -m "chore(release): ${{ steps.version.outputs.version }}"
          git push origin ${{ github.ref_name }}

          # Create and push tag
          git tag ${{ steps.version.outputs.tag }}
          git push origin ${{ steps.version.outputs.tag }}

  # Build release artifacts
  build-artifacts:
    runs-on: ubuntu-latest
    needs: version-management

    strategy:
      matrix:
        platform: [linux/amd64, linux/arm64]

    outputs:
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=semver,pattern={{version}},value=${{ needs.version-management.outputs.version }}
            type=semver,pattern={{major}}.{{minor}},value=${{ needs.version-management.outputs.version }}
            type=semver,pattern={{major}},value=${{ needs.version-management.outputs.version }}
            type=raw,value=latest,enable={{is_default_branch}}
          labels: |
            org.opencontainers.image.title=${{ github.repository }}
            org.opencontainers.image.description=Production release
            org.opencontainers.image.vendor=${{ github.repository_owner }}
            org.opencontainers.image.version=${{ needs.version-management.outputs.version }}

      - name: Build and push release image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: ${{ matrix.platform }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ needs.version-management.outputs.version }}
            BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VCS_REF=${{ github.sha }}
          target: production

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.version-management.outputs.version }}
          format: spdx-json
          output-file: sbom-${{ matrix.platform }}.spdx.json

      - name: Sign container image
        if: ${{ secrets.COSIGN_PRIVATE_KEY != '' }}
        uses: sigstore/cosign-installer@v3

      - name: Sign image with cosign
        if: ${{ secrets.COSIGN_PRIVATE_KEY != '' }}
        run: |
          echo "${{ secrets.COSIGN_PRIVATE_KEY }}" | cosign sign --key env://COSIGN_PRIVATE_KEY ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.version-management.outputs.version }}
        env:
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}

      - name: Upload SBOM
        uses: actions/upload-artifact@v3
        with:
          name: sbom-${{ strategy.job-index }}
          path: sbom-${{ matrix.platform }}.spdx.json

  # Security and quality validation
  release-validation:
    runs-on: ubuntu-latest
    needs: [version-management, build-artifacts]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run comprehensive security scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.version-management.outputs.version }}
          format: "table"
          exit-code: "1"
          severity: "CRITICAL,HIGH"

      - name: Run integration tests
        run: |
          docker run -d \
            --name release-test \
            -p 3000:3000 \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.version-management.outputs.version }}
            
          # Wait for startup
          timeout 60 bash -c 'until curl -f http://localhost:3000/health; do sleep 2; done'

          # Run release validation tests
          npm ci
          npm run test:release

          # Cleanup
          docker rm -f release-test

      - name: Performance benchmark
        run: |
          docker run -d \
            --name perf-test \
            -p 3000:3000 \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.version-management.outputs.version }}
            
          # Install and run K6 performance tests
          curl -L https://github.com/grafana/k6/releases/download/v0.46.0/k6-v0.46.0-linux-amd64.tar.gz | tar xvz --strip-components 1
          ./k6 run tests/performance/release-benchmark.js

          docker rm -f perf-test

  # Documentation and release notes
  generate-docs:
    runs-on: ubuntu-latest
    needs: version-management

    outputs:
      release-notes: ${{ steps.notes.outputs.notes }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Generate API documentation
        run: |
          npm ci
          npm run docs:generate || echo "No docs generation script found"

      - name: Generate release notes
        id: notes
        run: |
          # Generate comprehensive release notes
          cat > release-notes.md << EOF
          # Release ${{ needs.version-management.outputs.version }}

          ## ðŸš€ What's New
          ${{ needs.version-management.outputs.changelog }}

          ## ðŸ“¦ Docker Images
          \`\`\`bash
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.version-management.outputs.version }}
          \`\`\`

          ## ðŸ”’ Security
          - âœ… Security scanned with Trivy
          - âœ… Container signed with Cosign
          - âœ… SBOM generated and attached

          ## ðŸ§ª Testing
          - âœ… Integration tests passed
          - âœ… Performance benchmarks completed
          - âœ… Security validation passed

          ## ðŸ“‹ Deployment
          Use the attached Kubernetes manifests for deployment.
          EOF

          # Save to output
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          cat release-notes.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate deployment manifests
        run: |
          mkdir -p deployment/

          # Kubernetes deployment
          cat > deployment/kubernetes.yaml << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: app-deployment
            labels:
              app: myapp
              version: ${{ needs.version-management.outputs.version }}
          spec:
            replicas: 3
            selector:
              matchLabels:
                app: myapp
            template:
              metadata:
                labels:
                  app: myapp
                  version: ${{ needs.version-management.outputs.version }}
              spec:
                containers:
                - name: app
                  image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.version-management.outputs.version }}
                  ports:
                  - containerPort: 3000
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "250m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: app-service
          spec:
            selector:
              app: myapp
            ports:
            - port: 80
              targetPort: 3000
            type: LoadBalancer
          EOF

          # Docker Compose
          cat > deployment/docker-compose.yml << EOF
          version: '3.8'
          services:
            app:
              image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.version-management.outputs.version }}
              ports:
                - "3000:3000"
              environment:
                NODE_ENV: production
              deploy:
                resources:
                  limits:
                    memory: 512M
                  reservations:
                    memory: 256M
          EOF

      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v3
        with:
          name: deployment-manifests
          path: |
            deployment/
            release-notes.md

  # Create GitHub Release
  create-release:
    runs-on: ubuntu-latest
    needs:
      [version-management, build-artifacts, release-validation, generate-docs]

    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v3

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.version-management.outputs.tag }}
          name: Release ${{ needs.version-management.outputs.version }}
          body: ${{ needs.generate-docs.outputs.release-notes }}
          draft: ${{ github.event.inputs.draft || false }}
          prerelease: ${{ github.event.inputs.prerelease || false }}
          files: |
            deployment-manifests/**
            sbom-*/*.spdx.json
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update latest release
        if: ${{ !github.event.inputs.prerelease }}
        run: |
          # Update "latest" tag to point to this release
          git tag -f latest ${{ needs.version-management.outputs.tag }}
          git push -f origin latest

  # Deploy to staging
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [version-management, create-release]
    environment: staging
    if: ${{ !github.event.inputs.draft }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to staging
        run: |
          echo "Deploying ${{ needs.version-management.outputs.version }} to staging"
          # Add staging deployment commands here
          # kubectl apply -f deployment/kubernetes.yaml

      - name: Run smoke tests
        run: |
          echo "Running smoke tests on staging"
          # Add smoke test commands

      - name: Update deployment status
        run: |
          echo "âœ… Staging deployment successful"

  # Production deployment (requires manual approval)
  deploy-production:
    runs-on: ubuntu-latest
    needs: [version-management, deploy-staging]
    environment: production
    if: ${{ !github.event.inputs.prerelease && !github.event.inputs.draft }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to production
        run: |
          echo "Deploying ${{ needs.version-management.outputs.version }} to production"
          # Add production deployment commands

      - name: Post-deployment verification
        run: |
          echo "Running production verification tests"
          # Add verification tests

      - name: Update deployment status
        run: |
          echo "ðŸš€ Production deployment successful"

  # Notify stakeholders
  notifications:
    runs-on: ubuntu-latest
    needs:
      [version-management, create-release, deploy-staging, deploy-production]
    if: always()

    steps:
      - name: Send Slack notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            ðŸŽ‰ Release ${{ needs.version-management.outputs.version }} Complete!

            ðŸ“¦ GitHub Release: Created
            ðŸš€ Staging: ${{ needs.deploy-staging.result }}
            ðŸŒŸ Production: ${{ needs.deploy-production.result }}

            ðŸ”— Release URL: https://github.com/${{ github.repository }}/releases/tag/${{ needs.version-management.outputs.tag }}
            ðŸ³ Docker: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.version-management.outputs.version }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Send email notification
        if: ${{ secrets.EMAIL_USERNAME != '' }}
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 587
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: "Release ${{ needs.version-management.outputs.version }} Deployed"
          body: |
            Release ${{ needs.version-management.outputs.version }} has been successfully deployed.

            Release Notes: https://github.com/${{ github.repository }}/releases/tag/${{ needs.version-management.outputs.tag }}
            Docker Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.version-management.outputs.version }}

            Deployment Status:
            - Staging: ${{ needs.deploy-staging.result }}
            - Production: ${{ needs.deploy-production.result }}
          to: devops@company.com
          from: Release Automation <noreply@company.com>

      - name: Create Jira deployment
        if: ${{ secrets.JIRA_TOKEN != '' }}
        run: |
          curl -X POST \
            -H "Authorization: Bearer ${{ secrets.JIRA_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{
              "deploymentSequenceNumber": ${{ github.run_number }},
              "updateSequenceNumber": ${{ github.run_number }},
              "displayName": "Release ${{ needs.version-management.outputs.version }}",
              "url": "https://github.com/${{ github.repository }}/releases/tag/${{ needs.version-management.outputs.tag }}",
              "description": "Automated release deployment",
              "lastUpdated": "'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'",
              "state": "successful",
              "pipeline": {
                "id": "release-pipeline",
                "displayName": "Release Pipeline",
                "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
              },
              "environment": {
                "id": "production",
                "displayName": "Production",
                "type": "production"
              }
            }' \
            "${{ secrets.JIRA_BASE_URL }}/rest/deployments/0.1/bulk"

  # Cleanup and maintenance
  cleanup:
    runs-on: ubuntu-latest
    needs: [notifications]
    if: always()

    steps:
      - name: Cleanup old artifacts
        run: |
          echo "Cleaning up temporary artifacts and caches"

      - name: Update metrics dashboard
        run: |
          echo "Updating release metrics and dashboards"

      - name: Archive release data
        run: |
          echo "Archiving release data for analytics"
