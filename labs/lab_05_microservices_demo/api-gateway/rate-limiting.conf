# File Location: labs/lab_05_microservices_demo/api-gateway/rate-limiting.conf

# Rate limiting configuration for API Gateway

# Define rate limiting zones
limit_req_zone $binary_remote_addr zone=global_limit:50m rate=100r/s;
limit_req_zone $binary_remote_addr zone=api_limit:30m rate=10r/s;
limit_req_zone $binary_remote_addr zone=auth_limit:10m rate=5r/s;
limit_req_zone $binary_remote_addr zone=upload_limit:10m rate=1r/s;
limit_req_zone $binary_remote_addr zone=heavy_ops:10m rate=2r/s;

# Per-user rate limiting (requires authentication)
limit_req_zone $http_x_user_id zone=user_api:20m rate=50r/s;
limit_req_zone $http_x_user_id zone=user_auth:10m rate=10r/s;

# Geographic rate limiting
geo $limited_ip {
    default 0;
    # Add suspicious IP ranges here
    # 192.168.1.0/24 1;
}

map $limited_ip $geo_limit {
    0 "";
    1 "geo_limited";
}

limit_req_zone $binary_remote_addr zone=geo_limited:10m rate=1r/s;

# API endpoint specific configurations
map $request_uri $api_zone {
    ~^/api/auth/ "auth_limit";
    ~^/api/upload/ "upload_limit";
    ~^/api/orders/batch "heavy_ops";
    ~^/api/notifications/broadcast "heavy_ops";
    default "api_limit";
}

# Rate limiting status responses
map $limit_req_status $rate_limit_response {
    "" '{"status":"ok"}';
    "PASSED" '{"status":"ok"}';
    "DELAYED" '{"status":"delayed","message":"Request delayed due to rate limiting"}';
    "REJECTED" '{"status":"rejected","error":"Rate limit exceeded","code":429}';
    "DELAYED_DRY_RUN" '{"status":"would_delay"}';
    "REJECTED_DRY_RUN" '{"status":"would_reject"}';
}

# Burst configurations for different endpoint types
map $request_uri $burst_size {
    ~^/api/auth/login$ 3;
    ~^/api/auth/register$ 2;
    ~^/api/auth/ 5;
    ~^/api/upload/ 1;
    ~^/api/orders/ 10;
    ~^/api/users/ 15;
    ~^/api/notifications/ 20;
    default 10;
}

# Dynamic rate limiting based on response codes
map $upstream_status $should_limit {
    ~^[23] 0;  # Don't limit successful responses
    ~^4 1;     # Limit client errors
    ~^5 2;     # Heavily limit server errors
    default 1;
}

# Rate limiting configuration per location
# Usage in server block:

# For authentication endpoints
# location /api/auth/ {
#     limit_req zone=auth_limit burst=3 nodelay;
#     limit_req zone=user_auth burst=5 delay=2;
#     limit_req_status 429;
#     
#     if ($geo_limit) {
#         limit_req zone=geo_limited burst=1 nodelay;
#     }
#     
#     # Custom error response
#     error_page 429 @rate_limit_error;
# }

# For general API endpoints  
# location /api/ {
#     limit_req zone=api_limit burst=10 delay=5;
#     limit_req zone=user_api burst=20 nodelay;
#     limit_req_status 429;
#     
#     # Add rate limit headers
#     add_header X-RateLimit-Zone $api_zone always;
#     add_header X-RateLimit-Burst $burst_size always;
# }

# Error handling location
location @rate_limit_error {
    internal;
    add_header Content-Type application/json always;
    add_header X-RateLimit-Exceeded true always;
    add_header X-RateLimit-Reset-Time $msec always;
    return 429 '{"error":"Rate limit exceeded","message":"Too many requests. Please slow down.","retry_after":60,"documentation":"https://docs.example.com/rate-limits"}';
}

# Rate limit monitoring endpoint
location /gateway/rate-limit-status {
    access_log off;
    allow 127.0.0.1;
    allow 10.0.0.0/8;
    allow 172.16.0.0/12;
    allow 192.168.0.0/16;
    deny all;
    
    content_by_lua_block {
        local cjson = require "cjson"
        
        -- Get rate limit zone statistics
        local zones = {
            "global_limit",
            "api_limit", 
            "auth_limit",
            "upload_limit",
            "heavy_ops",
            "user_api",
            "user_auth"
        }
        
        local stats = {}
        for _, zone in ipairs(zones) do
            -- In a real implementation, you would query nginx statistics
            stats[zone] = {
                zone = zone,
                requests = math.random(1000, 10000),
                rejected = math.random(0, 100),
                delayed = math.random(0, 50)
            }
        end
        
        ngx.header["Content-Type"] = "application/json"
        ngx.say(cjson.encode({
            status = "ok",
            timestamp = ngx.time(),
            zones = stats
        }))
    }
}

# Lua script for advanced rate limiting logic
init_by_lua_block {
    -- Custom rate limiting functions
    function check_user_quota(user_id, endpoint)
        -- Implement custom business logic for user quotas
        -- This could check database for user tier, subscription, etc.
        return true
    end
    
    function log_rate_limit_violation(ip, user_id, endpoint)
        -- Log rate limit violations for analysis
        ngx.log(ngx.WARN, "Rate limit violation: ", ip, " user:", user_id, " endpoint:", endpoint)
    end
}

# Advanced rate limiting with custom logic
access_by_lua_block {
    local user_id = ngx.var.http_x_user_id
    local endpoint = ngx.var.request_uri
    local ip = ngx.var.remote_addr
    
    -- Custom business logic rate limiting
    if user_id then
        if not check_user_quota(user_id, endpoint) then
            log_rate_limit_violation(ip, user_id, endpoint)
            ngx.status = 429
            ngx.header["Content-Type"] = "application/json"
            ngx.say('{"error":"User quota exceeded","message":"Your account has exceeded the allowed request quota"}')
            ngx.exit(429)
        end
    end
    
    -- IP-based blocking for suspicious activity
    local blocked_ips_key = "blocked_ips:" .. ip
    -- In real implementation, check Redis for blocked IPs
    
    -- Log all requests for analysis
    ngx.log(ngx.INFO, "Request: ", ip, " -> ", endpoint, " User: ", user_id or "anonymous")
}